#version 450

#define WORKGROUP_SIZE 32

layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

struct Cluster
{
    vec3 pMin;
    vec3 pMax;
    uint triangleStart;
    uint triangleEnd;
};


layout(std430, set = 0, binding = 0) buffer readonly ClustersIn {
   Cluster indata[ ];
};

layout(std430, set = 0, binding = 1) buffer readonly TrianglesIn {
   uint inTriangles[ ];
};

layout(std430, set = 0, binding = 2) buffer writeonly TrianglesOut {
   uint outTriangles[ ];
};

layout(std430, set = 0, binding = 3) buffer NumVertices {
    uint indexCount; 
    uint instanceCount;
    uint firstIndex;
    uint vertexOffset;
    uint firstInstance;
} numVertices;

layout(set = 0, binding = 4) uniform UBOMats {
    mat4 model; //unused
    mat4 lastView;
    mat4 lastProj;
} ubomats;

layout(set = 0, binding = 5) uniform sampler2D lastHZB;

layout(std430, set = 0, binding = 6) buffer readonly ProjectedError {
   vec2 errorData[ ];
};

layout(push_constant) uniform PushConstants {
    int numClusters;
    float threshold;
} pcs;

// Naive AABB compute
void getScreenAABB(Cluster c, inout vec4 screenXY, inout float minZ)
{
    //TODO: reduce number of points check here
    vec4 p0 = vec4(c.pMin.x,c.pMin.y,c.pMin.z,1.0);
    vec4 p1 = vec4(c.pMax.x,c.pMin.y,c.pMin.z,1.0);
    vec4 p2 = vec4(c.pMin.x,c.pMax.y,c.pMin.z,1.0);
    vec4 p3 = vec4(c.pMin.x,c.pMin.y,c.pMax.z,1.0);
    vec4 p4 = vec4(c.pMax.x,c.pMax.y,c.pMin.z,1.0);
    vec4 p5 = vec4(c.pMin.x,c.pMax.y,c.pMax.z,1.0);
    vec4 p6 = vec4(c.pMax.x,c.pMin.y,c.pMax.z,1.0);
    vec4 p7 = vec4(c.pMax.x,c.pMax.y,c.pMax.z,1.0);

    vec4 p0h = ubomats.lastProj * ubomats.lastView * p0;
    vec4 p1h = ubomats.lastProj * ubomats.lastView * p1;
    vec4 p2h = ubomats.lastProj * ubomats.lastView * p2;
    vec4 p3h = ubomats.lastProj * ubomats.lastView * p3;
    vec4 p4h = ubomats.lastProj * ubomats.lastView * p4;
    vec4 p5h = ubomats.lastProj * ubomats.lastView * p5;
    vec4 p6h = ubomats.lastProj * ubomats.lastView * p6;
    vec4 p7h = ubomats.lastProj * ubomats.lastView * p7;

    p0h.xyz /= p0h.w;
    p1h.xyz /= p1h.w;
    p2h.xyz /= p2h.w;
    p3h.xyz /= p3h.w;
    p4h.xyz /= p4h.w;
    p5h.xyz /= p5h.w;
    p6h.xyz /= p6h.w;
    p7h.xyz /= p7h.w;

    p0h = p0h*0.5+0.5;
    p1h = p1h*0.5+0.5;
    p2h = p2h*0.5+0.5;
    p3h = p3h*0.5+0.5;
    p4h = p4h*0.5+0.5;
    p5h = p5h*0.5+0.5;
    p6h = p6h*0.5+0.5;
    p7h = p7h*0.5+0.5;

    minZ = 1.0;
    minZ = min(minZ, min(p0h.z,p1h.z));
    minZ = min(minZ, min(p2h.z,p3h.z));
    minZ = min(minZ, min(p4h.z,p5h.z));
    minZ = min(minZ, min(p6h.z,p7h.z));

    vec2 minXY = vec2(1.0);
    minXY = min(minXY, min(p0h.xy,p1h.xy));
    minXY = min(minXY, min(p2h.xy,p3h.xy));
    minXY = min(minXY, min(p4h.xy,p5h.xy));
    minXY = min(minXY, min(p6h.xy,p7h.xy));

    vec2 maxXY = vec2(0.0);
    maxXY = max(maxXY, max(p0h.xy,p1h.xy));
    maxXY = max(maxXY, max(p2h.xy,p3h.xy));
    maxXY = max(maxXY, max(p4h.xy,p5h.xy));
    maxXY = max(maxXY, max(p6h.xy,p7h.xy));

    screenXY.xy = minXY;
    screenXY.zw = maxXY;
}

bool frustrumCulling(vec3 pos, mat4 currView, mat4 currProj)
{
    vec4 hpos = currProj * currView * vec4(pos,1.0);
    if(hpos.w==0.0) return false;
    hpos.xyz /= hpos.w;
    return hpos.x>-1.1&&hpos.x<1.1&&hpos.y>-1.1&&hpos.y<1.1&&hpos.z>-1.1&&hpos.z<1.1;
}


void main()
{
    uint index = gl_GlobalInvocationID.x;
    
    if(index >= pcs.numClusters) return;

    bool culled = false;
    // Cluster currCluster = indata[index];
    // vec4 clipXY;
    // float minZ;
    // getScreenAABB(currCluster,clipXY,minZ);
    // vec4 screenSize = textureSize(lastHZB, 0).xyxy;
    // vec4 screenXY = clipXY * screenSize;
    // vec2 screenSpan = screenXY.zw-screenXY.xy;
    // float hzbLevel = ceil(log2(max(screenSpan.x,screenSpan.y)));
    // float hzbLevel_1 = max(hzbLevel-1,0);
    // float texScale = exp2(-hzbLevel_1);
    // vec2 texSpan = ceil(screenXY.zw*texScale) - floor(screenXY.xy*texScale);
    // if(texSpan.x<2&&texSpan.y<2) hzbLevel = hzbLevel_1;
    // float z1 = textureLod(lastHZB,vec2(clipXY.x,clipXY.y),hzbLevel).x;
    // float z2 = textureLod(lastHZB,vec2(clipXY.x,clipXY.w),hzbLevel).x;
    // float z3 = textureLod(lastHZB,vec2(clipXY.z,clipXY.y),hzbLevel).x;
    // float z4 = textureLod(lastHZB,vec2(clipXY.z,clipXY.w),hzbLevel).x;
    // float maxHiz = max(max(z1,z2),max(z3,z4));
    // if(minZ>maxHiz+0.02) culled = true;

    culled = culled || (errorData[index].y <= pcs.threshold||errorData[index].x > pcs.threshold);
    if(!culled)
    {
        uint totalVertices = (indata[index].triangleEnd - indata[index].triangleStart)*3;
        uint nIdx = atomicAdd(numVertices.indexCount, totalVertices);
        for(uint i = 0; i < totalVertices / 3; i++)
        {
            uint inIdx = indata[index].triangleStart * 3 + 3 * i;
            uint outIdx = nIdx + 3 * i;
            outTriangles[outIdx + 0] = inTriangles[inIdx + 0];
            outTriangles[outIdx + 1] = inTriangles[inIdx + 1];
            outTriangles[outIdx + 2] = inTriangles[inIdx + 2];
        }
    }
}